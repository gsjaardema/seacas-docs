

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>&lt;no title&gt; &mdash; SEACAS 2021/03/02 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> SEACAS
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul class="simple">
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SEACAS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>&lt;no title&gt;</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/doc.poly.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>\page polyhedra Polyhedral Element Support
\section poly Storage of 3D arbitrary polyhedra elements in Exodus.</p>
<p>The 3D polyhedra elements are represented as elements with a variable
number of faces in their connectivity.  The faces can either be
regular faces such as quadrilateral or triangles; or they can be
topologically two-dimensional arbitrary polyhedra themselves.</p>
<p>An arbitrary polyhedra 3D element block will have an element type of
“nfaced” or “NFACED”.</p>
<p>The faces that are used in the connectivity of this block should be
defined in one or more face blocks.  If the faces are arbitrary
polyhedra, then they will have a face type of “nsided” or “NSIDED”.</p>
<p>An annotated example of defining an arbitrary polyhedral element block
consisting of 3 elements is shown below.</p>
<p>The three elements have the following geometry:</p>
<ul class="simple">
<li><p>Element 1: 5 faces.</p>
<ul>
<li><p>Face 1: triangle with nodes 5, 6, 8</p></li>
<li><p>Face 2: triangle with nodes 2, 1, 4</p></li>
<li><p>Face 3: quadrilateral with nodes 6, 2, 4, 8</p></li>
<li><p>Face 4: quadrilateral with nodes 8, 4, 1, 5</p></li>
<li><p>Face 5: quadrilateral with nodes 1, 2, 6, 5</p></li>
</ul>
</li>
<li><p>Element 2: 5 faces.</p>
<ul>
<li><p>Face 6: triangle with nodes 5, 8, 7</p></li>
<li><p>Face 7: triangle with nodes 1, 3, 4</p></li>
<li><p>Face 8: quadrilateral with nodes 7, 8, 4, 3</p></li>
<li><p>Face 9: quadrilateral with nodes 7, 3, 1, 5</p></li>
<li><p>Face 4: quadrilateral with nodes 8, 4, 1, 5 (shared with element 1)</p></li>
</ul>
</li>
<li><p>Element 3: 7 faces.</p>
<ul>
<li><p>Face  8: quadrilateral with nodes 7, 8, 4, 3 (shared with element 2)</p></li>
<li><p>Face 10: pentagonal with nodes 8, 4, 14, 10, 12</p></li>
<li><p>Face 11: pentagonal with nodes 7, 11, 9, 13, 3</p></li>
<li><p>Face 12: quadrilateral with nodes 7, 8, 12, 11</p></li>
<li><p>Face 13: quadrilateral with nodes 11, 12, 10, 9</p></li>
<li><p>Face 14: quadrilateral with nodes 9, 10, 14, 13</p></li>
<li><p>Face 15: quadrilateral with nodes 12, 14, 4, 3</p></li>
</ul>
</li>
</ul>
<p>The Exodus model is created via the following calls:</p>
<ul>
<li><p>Output the initial information.  Since the model contains faces and
a face block, the “extended” version of the <code class="docutils literal notranslate"><span class="pre">ex_put_init_ext()</span></code> call must be used:</p>
<div class="highlight-{.c} notranslate"><div class="highlight"><pre><span></span>ex_init_params par;
strcpy( par.title, &quot;This is the title&quot; );
par.num_dim = 3;
par.num_nodes = 14;
par.num_edge = 0;
par.num_edge_blk = 0;
par.num_face = 15;
par.num_face_blk = 1;
par.num_elem = 3;
par.num_elem_blk = 1;
par.num_node_sets = 0;
par.num_edge_sets = 0;
par.num_face_sets = 0;
par.num_side_sets = 0;
par.num_elem_sets = 0;
par.num_node_maps = 0;
par.num_edge_maps = 0;
par.num_face_maps = 0;
par.num_elem_maps = 0;

ex_put_init_ext (exoid, &amp;par);
</pre></div>
</div>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">*</span> <span class="n">Coordinate</span> <span class="n">output</span> <span class="ow">is</span> <span class="n">normal</span><span class="o">...</span>

<span class="o">*</span> <span class="n">Define</span> <span class="n">the</span> <span class="n">face</span> <span class="n">block</span><span class="o">.</span>

<span class="o">~~~~</span><span class="p">{</span><span class="o">.</span><span class="n">c</span><span class="p">}</span>
   <span class="n">block_name</span> <span class="o">=</span> <span class="s2">&quot;face_block_1&quot;</span><span class="p">;</span>
   <span class="n">num_face_in_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
   <span class="n">num_total_nodes_per_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">58</span><span class="p">;</span>
   <span class="n">block_id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

   <span class="n">ex_put_block</span> <span class="p">(</span><span class="n">exoid</span><span class="p">,</span> <span class="n">EX_FACE_BLOCK</span><span class="p">,</span> <span class="n">block_id</span><span class="p">,</span> <span class="s2">&quot;nsided&quot;</span><span class="p">,</span>
		 <span class="n">num_face_in_block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		 <span class="n">num_total_nodes_per_blk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		 <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="n">ex_put_name</span><span class="p">(</span><span class="n">exoid</span><span class="p">,</span> <span class="n">EX_FACE_BLOCK</span><span class="p">,</span> <span class="n">block_id</span><span class="p">,</span> <span class="n">block_name</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Output the face connectivity for “face_block_1”.
The data for the face connectivity is listed above; a portion is shown below…</p></li>
</ul>
<div class="highlight-{.c} notranslate"><div class="highlight"><pre><span></span>   connect = (int *) calloc(num_total_nodes_per_blk[0], sizeof(int));
   i = 0
   connect[i++] = 5;
   connect[i++] = 6;
   connect[i++] = 8; /* connectivity of face 1 of element 1 */

   connect[i++] = 2;
   connect[i++] = 1;
   connect[i++] = 4; /* face 2 of element 1 */

   connect[i++] = 6;
   connect[i++] = 2;
   connect[i++] = 4;
   connect[i++] = 8; /* face 3 of element 1 */

   connect[i++] = 8;
   connect[i++] = 4;
   connect[i++] = 1;
   connect[i++] = 5; /* face 4 of element 1 */

   connect[i++] = 1;
   connect[i++] = 2;
   connect[i++] = 6;
   connect[i++] = 5; /*  face 5 of element 1 */

   connect[i++] = 5;
   connect[i++] = 8;
   connect[i++] = 7; /* connectivity of face 1 of element 2 */

   ... and so on....
   assert(i == num_total_nodes_per_blk[0]);

   ex_put_conn (exoid, EX_FACE_BLOCK, block_id, connect, NULL, NULL);
</pre></div>
</div>
<ul class="simple">
<li><p>Output the number of nodes per face count for “face_block_1”:</p></li>
</ul>
<div class="highlight-{.c} notranslate"><div class="highlight"><pre><span></span>   j = 0;
   nnpe[ 1] = 3;   /* Face 1 */
   nnpe[ 2] = 3;
   nnpe[ 3] = 4;  
   nnpe[ 4] = 4;
   nnpe[ 5] = 4;
   nnpe[ 6] = 3;
   nnpe[ 7] = 3;
   nnpe[ 8] = 4;
   nnpe[ 9] = 4;
   nnpe[10] = 5;  
   nnpe[11] = 5;
   nnpe[12] = 4;
   nnpe[13] = 4;
   nnpe[14] = 4;
   nnpe[15] = 4;  
   
   ex_put_entity_count_per_polyhedra(exoid, EX_FACE_BLOCK, block_id, nnpe);
</pre></div>
</div>
<ul class="simple">
<li><p>The face block is now fully defined; now define the nfaced element
block which uses these faces.</p></li>
</ul>
<div class="highlight-{.c} notranslate"><div class="highlight"><pre><span></span>   block_name = &quot;nfaced_1&quot;;

   num_elem_in_block = 3;
   num_total_faces_per_blk = 5 + 5 + 7;
   block_id = 10;

   ex_put_block (exoid, EX_ELEM_BLOCK, block_id, &quot;nfaced&quot;,
		 num_elem_in_block,
		 0, /* nodes */
		 0, /* edges  */
		 num_total_faces_per_blk,
		 0); /* attribute count */
   ex_put_name(exoid, EX_ELEM_BLOCK, block_id, block_name);
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">ex_put_block()</span></code> function, the element type is “nfaced”.  The
connectivity is defined in terms of the faces, so the node and edge
arguments are passed zeros.  The nodal connectivity can be defined,
but it isn’t required.  The face connectivity argument for an
nfaced block is the total number of faces in the connectivity for all
elements in the nfaced block.</p>
<ul class="simple">
<li><p>Write the face connectivity:</p></li>
</ul>
<div class="highlight-{.c} notranslate"><div class="highlight"><pre><span></span>   /* write element-face connectivity */
   connect = (int *) calloc(num_total_faces_per_blk, sizeof(int));

   i = 0;
   connect[i++] = 1;
   connect[i++] = 2;
   connect[i++] = 3;
   connect[i++] = 4;
   connect[i++] = 5;
   
   connect[i++] = 4;
   connect[i++] = 6;
   connect[i++] = 7;
   connect[i++] = 8;
   connect[i++] = 9;

   connect[i++] = 8;
   connect[i++] = 10;
   connect[i++] = 11;
   connect[i++] = 12;
   connect[i++] = 13;
   connect[i++] = 14;
   connect[i++] = 15;

   assert(i == num_total_faces_per_blk);
   ex_put_conn (exoid, EX_ELEM_BLOCK, block_id, NULL, NULL, connect);
</pre></div>
</div>
<ul class="simple">
<li><p>Output the number of faces per element count for “nfaced_1”:</p></li>
</ul>
<div class="highlight-{.c} notranslate"><div class="highlight"><pre><span></span>   nnpe[1] = 5;  /* Number of faces per element 1 */
   nnpe[2] = 5;  /* Number of faces per element 2 */
   nnpe[3] = 7;  /* Number of faces per element 3 */

   ex_put_entity_count_per_polyhedra(exoid, EX_ELEM_BLOCK, block_id, nnpe);
</pre></div>
</div>
<ul class="simple">
<li><p>That’s all; the rest of the calls are the same as normal Exodus except:</p>
<ul>
<li><p>There is a similar <code class="docutils literal notranslate"><span class="pre">ex_get_entity_count_per_polyhedra()</span></code> function for read.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">ex_get_block()</span></code> functions return the total number of nodes or
faces for all faces or element for “nfaced” and “nsided” blocks
and not the number per element</p></li>
</ul>
</li>
<li><p>An example read/write usage is shown in the
<a class="reference external" href="../test/testwt-nfaced.c">testwt-nfaced.c</a> and <a class="reference external" href="../test/testrd-nfaced.c">testrd-nfaced</a> files.</p></li>
<li><p>These changes are in Exodus version v4.93 and later.</p></li>
</ul>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Gregory Sjaardema.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>