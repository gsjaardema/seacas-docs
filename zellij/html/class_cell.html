<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zellij: Cell Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zellij
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_cell-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Cell Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_cell_8h_source.html">Cell.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad84ca3e6d2a2df084abd62541449f15d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#ad84ca3e6d2a2df084abd62541449f15d">get_coordinate_range</a> (enum <a class="el" href="_cell_8h.html#ae3996976d8ffb3e58d88f58227473f8e">Axis</a>) const</td></tr>
<tr class="separator:ad84ca3e6d2a2df084abd62541449f15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3670af22245d86115cfce60febd8489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#ad3670af22245d86115cfce60febd8489">initialize</a> (size_t i, size_t j, std::shared_ptr&lt; <a class="el" href="class_unit_cell.html">UnitCell</a> &gt; <a class="el" href="class_cell.html#af8a1a955762f25756378518acc9a1ad9">region</a>)</td></tr>
<tr class="separator:ad3670af22245d86115cfce60febd8489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7338ee252aec11060cf64605f8244078"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_unit_cell.html">UnitCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a7338ee252aec11060cf64605f8244078">unit</a> () const</td></tr>
<tr class="memdesc:a7338ee252aec11060cf64605f8244078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide access to the <a class="el" href="class_unit_cell.html">UnitCell</a> that this cell uses.  <a href="class_cell.html#a7338ee252aec11060cf64605f8244078">More...</a><br /></td></tr>
<tr class="separator:a7338ee252aec11060cf64605f8244078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a1a955762f25756378518acc9a1ad9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Ioss::Region &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#af8a1a955762f25756378518acc9a1ad9">region</a> () const</td></tr>
<tr class="memdesc:af8a1a955762f25756378518acc9a1ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide access to the Ioss::Region in the unit_cell that this cell uses.  <a href="class_cell.html#af8a1a955762f25756378518acc9a1ad9">More...</a><br /></td></tr>
<tr class="separator:af8a1a955762f25756378518acc9a1ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220ee45fbcb545142b02fd611dec7dba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a220ee45fbcb545142b02fd611dec7dba">has_neighbor_i</a> () const</td></tr>
<tr class="memdesc:a220ee45fbcb545142b02fd611dec7dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this cell has a neighbor to its "left" (lower i)  <a href="class_cell.html#a220ee45fbcb545142b02fd611dec7dba">More...</a><br /></td></tr>
<tr class="separator:a220ee45fbcb545142b02fd611dec7dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118b54eb756095d6911ad1829ec82fdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a118b54eb756095d6911ad1829ec82fdb">has_neighbor_j</a> () const</td></tr>
<tr class="memdesc:a118b54eb756095d6911ad1829ec82fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this cell has a neighbor "below it" (lower j)  <a href="class_cell.html#a118b54eb756095d6911ad1829ec82fdb">More...</a><br /></td></tr>
<tr class="separator:a118b54eb756095d6911ad1829ec82fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bb03eff9ffedacc47231f0ffa8474f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a99bb03eff9ffedacc47231f0ffa8474f">has_neighbor</a> (enum <a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a> loc) const</td></tr>
<tr class="separator:a99bb03eff9ffedacc47231f0ffa8474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77f605d3a5d00613ffc464904c970f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#aa77f605d3a5d00613ffc464904c970f7">processor_boundary</a> (enum <a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a> loc) const</td></tr>
<tr class="separator:aa77f605d3a5d00613ffc464904c970f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08892066918de5cee1d70ffd51aa25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a2e08892066918de5cee1d70ffd51aa25">added_node_count</a> (enum <a class="el" href="_cell_8h.html#a46c8a310cf4c094f8c80e1cb8dc1f911">Mode</a> mode, bool equivalence_nodes) const</td></tr>
<tr class="separator:a2e08892066918de5cee1d70ffd51aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6803aba8004be207766acf553e251101"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a6803aba8004be207766acf553e251101">processor_boundary_node_count</a> () const</td></tr>
<tr class="separator:a6803aba8004be207766acf553e251101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f88c3c38a2236972cbf43bc8997ee3b"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a4f88c3c38a2236972cbf43bc8997ee3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_cell.html#a4f88c3c38a2236972cbf43bc8997ee3b">populate_node_communication_map</a> (const std::vector&lt; INT &gt; &amp;node_map, std::vector&lt; INT &gt; &amp;nodes, std::vector&lt; INT &gt; &amp;procs) const</td></tr>
<tr class="separator:a4f88c3c38a2236972cbf43bc8997ee3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466a9210d7b8e35681a97027beddbfc7"><td class="memItemLeft" align="right" valign="top">std::array&lt; int, 9 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a466a9210d7b8e35681a97027beddbfc7">categorize_processor_boundary_nodes</a> (int <a class="el" href="class_cell.html#ad09705dda2440b70b47043513ebe3407">rank</a>) const</td></tr>
<tr class="separator:a466a9210d7b8e35681a97027beddbfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09705dda2440b70b47043513ebe3407"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#ad09705dda2440b70b47043513ebe3407">rank</a> (enum <a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a> loc) const</td></tr>
<tr class="memdesc:ad09705dda2440b70b47043513ebe3407"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mpi rank that this cell, or the neighboring cells, will be on in a parallel run.  <a href="class_cell.html#ad09705dda2440b70b47043513ebe3407">More...</a><br /></td></tr>
<tr class="separator:ad09705dda2440b70b47043513ebe3407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd578372b164b6939c268893ff452302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#afd578372b164b6939c268893ff452302">set_rank</a> (enum <a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a> loc, int my_rank)</td></tr>
<tr class="memdesc:afd578372b164b6939c268893ff452302"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mpi rank that this cell will be on in a parallel run.  <a href="class_cell.html#afd578372b164b6939c268893ff452302">More...</a><br /></td></tr>
<tr class="separator:afd578372b164b6939c268893ff452302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471f1552d0ee64cf041663611d40329e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a471f1552d0ee64cf041663611d40329e">categorize_nodes</a> (enum <a class="el" href="_cell_8h.html#a46c8a310cf4c094f8c80e1cb8dc1f911">Mode</a> mode) const</td></tr>
<tr class="separator:a471f1552d0ee64cf041663611d40329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71406c8b373077afa3d99f4397f6370d"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a71406c8b373077afa3d99f4397f6370d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; INT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_cell.html#a71406c8b373077afa3d99f4397f6370d">generate_node_map</a> (<a class="el" href="_cell_8h.html#a46c8a310cf4c094f8c80e1cb8dc1f911">Mode</a> mode, bool equivalance_nodes, INT) const</td></tr>
<tr class="separator:a71406c8b373077afa3d99f4397f6370d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916857aabe58d4a92be1f3094945e80f"><td class="memTemplParams" colspan="2">template&lt;typename INT &gt; </td></tr>
<tr class="memitem:a916857aabe58d4a92be1f3094945e80f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_cell.html#a916857aabe58d4a92be1f3094945e80f">populate_neighbor</a> (<a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a> location, const std::vector&lt; INT &gt; &amp;map, const <a class="el" href="class_cell.html">Cell</a> &amp;neighbor) const</td></tr>
<tr class="separator:a916857aabe58d4a92be1f3094945e80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1bde579a85087af8bd96faecfd6820ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a1bde579a85087af8bd96faecfd6820ff">min_I_nodes</a></td></tr>
<tr class="separator:a1bde579a85087af8bd96faecfd6820ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb33c55b234e7c96a1aff9805f3ac77b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#adb33c55b234e7c96a1aff9805f3ac77b">min_J_nodes</a></td></tr>
<tr class="separator:adb33c55b234e7c96a1aff9805f3ac77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b1af8720f376dc512ae23e00ae1f57"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#aa8b1af8720f376dc512ae23e00ae1f57">m_i</a> {0}</td></tr>
<tr class="memdesc:aa8b1af8720f376dc512ae23e00ae1f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>i</code> location of this entry in the grid.  <a href="class_cell.html#aa8b1af8720f376dc512ae23e00ae1f57">More...</a><br /></td></tr>
<tr class="separator:aa8b1af8720f376dc512ae23e00ae1f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a01e88b450d5b0b3ddc9cf887e9cdb1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a4a01e88b450d5b0b3ddc9cf887e9cdb1">m_j</a> {0}</td></tr>
<tr class="memdesc:a4a01e88b450d5b0b3ddc9cf887e9cdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>j</code> location of this entry in the grid.  <a href="class_cell.html#a4a01e88b450d5b0b3ddc9cf887e9cdb1">More...</a><br /></td></tr>
<tr class="separator:a4a01e88b450d5b0b3ddc9cf887e9cdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e4ccbd26b3c959dfb05ccc5ac7e3d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a1e2e4ccbd26b3c959dfb05ccc5ac7e3d">m_globalNodeIdOffset</a> {0}</td></tr>
<tr class="separator:a1e2e4ccbd26b3c959dfb05ccc5ac7e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642bfeb129251cc33b41dbb0954917"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#acb642bfeb129251cc33b41dbb0954917">m_localNodeIdOffset</a> {0}</td></tr>
<tr class="separator:acb642bfeb129251cc33b41dbb0954917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c23bf0c2c37818b86113551337ce8e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a95c23bf0c2c37818b86113551337ce8e">m_communicationNodeOffset</a> {0}</td></tr>
<tr class="separator:a95c23bf0c2c37818b86113551337ce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad984813c7c3dfe99b4e587077ea1cbfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#ad984813c7c3dfe99b4e587077ea1cbfb">m_communicationNodeCount</a> {0}</td></tr>
<tr class="memdesc:ad984813c7c3dfe99b4e587077ea1cbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of node/proc pairs that this cell adds to the communication node map.  <a href="class_cell.html#ad984813c7c3dfe99b4e587077ea1cbfb">More...</a><br /></td></tr>
<tr class="separator:ad984813c7c3dfe99b4e587077ea1cbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923157494575c649ce70e8c3db83252d"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a923157494575c649ce70e8c3db83252d">m_globalElementIdOffset</a></td></tr>
<tr class="separator:a923157494575c649ce70e8c3db83252d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdc71b6f336a738b5169fa8777177cf"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#acfdc71b6f336a738b5169fa8777177cf">m_localElementIdOffset</a></td></tr>
<tr class="separator:acfdc71b6f336a738b5169fa8777177cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4951740a210293f8154706d8d03a471a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a4951740a210293f8154706d8d03a471a">m_localSurfaceOffset</a></td></tr>
<tr class="separator:a4951740a210293f8154706d8d03a471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac38133b8b253d32582a6275d41057b2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#aac38133b8b253d32582a6275d41057b2">m_offX</a> {0.0}</td></tr>
<tr class="separator:aac38133b8b253d32582a6275d41057b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7107a40b87e8aa079bd5b10c7b4550"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a0d7107a40b87e8aa079bd5b10c7b4550">m_offY</a> {0.0}</td></tr>
<tr class="separator:a0d7107a40b87e8aa079bd5b10c7b4550"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab91310968b7d513398de9db8cc2299cf"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_unit_cell.html">UnitCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#ab91310968b7d513398de9db8cc2299cf">m_unitCell</a></td></tr>
<tr class="memdesc:ab91310968b7d513398de9db8cc2299cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_unit_cell.html">UnitCell</a> that occupies this location in the grid / latice.  <a href="class_cell.html#ab91310968b7d513398de9db8cc2299cf">More...</a><br /></td></tr>
<tr class="separator:ab91310968b7d513398de9db8cc2299cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fb0731d86f3798588e39c695665155"><td class="memItemLeft" align="right" valign="top">std::array&lt; int, 9 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cell.html#a35fb0731d86f3798588e39c695665155">m_ranks</a> {{0, -1, -1, -1, -1, -1, -1, -1, -1}}</td></tr>
<tr class="separator:a35fb0731d86f3798588e39c695665155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e08892066918de5cee1d70ffd51aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08892066918de5cee1d70ffd51aa25">&#9670;&nbsp;</a></span>added_node_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cell::added_node_count </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="_cell_8h.html#a46c8a310cf4c094f8c80e1cb8dc1f911">Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>equivalence_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of nodes that will be added to global node count when this cell is added to grid &ndash; accounts for coincident nodes if this cell has neighbor(s) </p>

</div>
</div>
<a id="a471f1552d0ee64cf041663611d40329e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471f1552d0ee64cf041663611d40329e">&#9670;&nbsp;</a></span>categorize_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Cell::categorize_nodes </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="_cell_8h.html#a46c8a310cf4c094f8c80e1cb8dc1f911">Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a vector of <code>node_count</code> length which has the following values:</p><ul>
<li>0: Node that is not shared with any "lower" neighbors.</li>
<li>1: Node on <code>min_I</code> face</li>
<li>2: Node on <code>min_J</code> face</li>
<li>3: Node on <code>min_I-min_J</code> line If <code>mode == PROCESSOR</code>, then modify due to processor boundaries... </li>
</ul>

</div>
</div>
<a id="a466a9210d7b8e35681a97027beddbfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466a9210d7b8e35681a97027beddbfc7">&#9670;&nbsp;</a></span>categorize_processor_boundary_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; int, 9 &gt; Cell::categorize_processor_boundary_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <code>std::array&lt;int,9&gt;</code> which categorizes whether the cells at each location are on the same rank as <code>rank</code>. A value of <code>1</code> means the cell at that location is on the same rank; a value of <code>0</code> means it is on a different rank. Used to determine which nodes have already been accounted for on this rank and which this cell will add to the processor-local count. </p>

</div>
</div>
<a id="a71406c8b373077afa3d99f4397f6370d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71406c8b373077afa3d99f4397f6370d">&#9670;&nbsp;</a></span>generate_node_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; INT &gt; Cell::generate_node_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_cell_8h.html#a46c8a310cf4c094f8c80e1cb8dc1f911">Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>equivalance_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad84ca3e6d2a2df084abd62541449f15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84ca3e6d2a2df084abd62541449f15d">&#9670;&nbsp;</a></span>get_coordinate_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; Cell::get_coordinate_range </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="_cell_8h.html#ae3996976d8ffb3e58d88f58227473f8e">Axis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99bb03eff9ffedacc47231f0ffa8474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bb03eff9ffedacc47231f0ffa8474f">&#9670;&nbsp;</a></span>has_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cell::has_neighbor </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return neighbor information for each possible direction. This is only valid after <code>grid.decompose()</code> has been called </p>

</div>
</div>
<a id="a220ee45fbcb545142b02fd611dec7dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220ee45fbcb545142b02fd611dec7dba">&#9670;&nbsp;</a></span>has_neighbor_i()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cell::has_neighbor_i </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this cell has a neighbor to its "left" (lower i) </p>

</div>
</div>
<a id="a118b54eb756095d6911ad1829ec82fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118b54eb756095d6911ad1829ec82fdb">&#9670;&nbsp;</a></span>has_neighbor_j()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cell::has_neighbor_j </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if this cell has a neighbor "below it" (lower j) </p>

</div>
</div>
<a id="ad3670af22245d86115cfce60febd8489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3670af22245d86115cfce60febd8489">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cell::initialize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_unit_cell.html">UnitCell</a> &gt;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a916857aabe58d4a92be1f3094945e80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916857aabe58d4a92be1f3094945e80f">&#9670;&nbsp;</a></span>populate_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cell::populate_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; INT &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_cell.html">Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f88c3c38a2236972cbf43bc8997ee3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f88c3c38a2236972cbf43bc8997ee3b">&#9670;&nbsp;</a></span>populate_node_communication_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename INT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Cell::populate_node_communication_map </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; INT &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; INT &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; INT &gt; &amp;&#160;</td>
          <td class="paramname"><em>procs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa77f605d3a5d00613ffc464904c970f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77f605d3a5d00613ffc464904c970f7">&#9670;&nbsp;</a></span>processor_boundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cell::processor_boundary </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if this cell has a processor boundary to the specified direction Note that cell cannot compute this, but is "told" this during decomposition of the owning <code><a class="el" href="class_grid.html">Grid</a></code> There is a processor boundary if the rank of the cell at that location is different than the rank of this cell... </p>

</div>
</div>
<a id="a6803aba8004be207766acf553e251101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6803aba8004be207766acf553e251101">&#9670;&nbsp;</a></span>processor_boundary_node_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cell::processor_boundary_node_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of nodes that this cell adds to the processor boundary node count. Assumes that cells are processed in "order", so accounts for corner nodes shared with another cell... Note that a node shared by more than one processor (e.g. a corner node) counts for each processor it is shared with. </p>

</div>
</div>
<a id="ad09705dda2440b70b47043513ebe3407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09705dda2440b70b47043513ebe3407">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Cell::rank </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mpi rank that this cell, or the neighboring cells, will be on in a parallel run. </p>

</div>
</div>
<a id="af8a1a955762f25756378518acc9a1ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a1a955762f25756378518acc9a1ad9">&#9670;&nbsp;</a></span>region()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;Ioss::Region&gt; Cell::region </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide access to the Ioss::Region in the unit_cell that this cell uses. </p>

</div>
</div>
<a id="afd578372b164b6939c268893ff452302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd578372b164b6939c268893ff452302">&#9670;&nbsp;</a></span>set_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cell::set_rank </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="_cell_8h.html#a68205bc086dabe7bc8d3ff37685c7f1e">Loc</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mpi rank that this cell will be on in a parallel run. </p>

</div>
</div>
<a id="a7338ee252aec11060cf64605f8244078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7338ee252aec11060cf64605f8244078">&#9670;&nbsp;</a></span>unit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_unit_cell.html">UnitCell</a>&gt; Cell::unit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide access to the <a class="el" href="class_unit_cell.html">UnitCell</a> that this cell uses. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad984813c7c3dfe99b4e587077ea1cbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad984813c7c3dfe99b4e587077ea1cbfb">&#9670;&nbsp;</a></span>m_communicationNodeCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cell::m_communicationNodeCount {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of node/proc pairs that this cell adds to the communication node map. </p>

</div>
</div>
<a id="a95c23bf0c2c37818b86113551337ce8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c23bf0c2c37818b86113551337ce8e">&#9670;&nbsp;</a></span>m_communicationNodeOffset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cell::m_communicationNodeOffset {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The offset into the commincation node output array for this cell in the file associated with the rank that this cell is on. Set by handle_communications() in <a class="el" href="_grid_8_c.html">Grid.C</a>. </p>

</div>
</div>
<a id="a923157494575c649ce70e8c3db83252d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923157494575c649ce70e8c3db83252d">&#9670;&nbsp;</a></span>m_globalElementIdOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, size_t&gt; Cell::m_globalElementIdOffset</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e2e4ccbd26b3c959dfb05ccc5ac7e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2e4ccbd26b3c959dfb05ccc5ac7e3d">&#9670;&nbsp;</a></span>m_globalNodeIdOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Cell::m_globalNodeIdOffset {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b1af8720f376dc512ae23e00ae1f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b1af8720f376dc512ae23e00ae1f57">&#9670;&nbsp;</a></span>m_i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cell::m_i {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>i</code> location of this entry in the grid. </p>

</div>
</div>
<a id="a4a01e88b450d5b0b3ddc9cf887e9cdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a01e88b450d5b0b3ddc9cf887e9cdb1">&#9670;&nbsp;</a></span>m_j</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cell::m_j {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>j</code> location of this entry in the grid. </p>

</div>
</div>
<a id="acfdc71b6f336a738b5169fa8777177cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdc71b6f336a738b5169fa8777177cf">&#9670;&nbsp;</a></span>m_localElementIdOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, size_t&gt; Cell::m_localElementIdOffset</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb642bfeb129251cc33b41dbb0954917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642bfeb129251cc33b41dbb0954917">&#9670;&nbsp;</a></span>m_localNodeIdOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Cell::m_localNodeIdOffset {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4951740a210293f8154706d8d03a471a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4951740a210293f8154706d8d03a471a">&#9670;&nbsp;</a></span>m_localSurfaceOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, size_t&gt; Cell::m_localSurfaceOffset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each surface/sideset, this is the offset into the output element/face lists for this cells data. 0-based. Indexed by surface name. </p>

</div>
</div>
<a id="aac38133b8b253d32582a6275d41057b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac38133b8b253d32582a6275d41057b2">&#9670;&nbsp;</a></span>m_offX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cell::m_offX {0.0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The offset that must be added to the <code>x</code> coordinates of the <a class="el" href="class_unit_cell.html">UnitCell</a> to place it in the correct global location of the output mesh </p>

</div>
</div>
<a id="a0d7107a40b87e8aa079bd5b10c7b4550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7107a40b87e8aa079bd5b10c7b4550">&#9670;&nbsp;</a></span>m_offY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Cell::m_offY {0.0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The offset that must be added to the <code>y</code> coordinates of the <a class="el" href="class_unit_cell.html">UnitCell</a> to place it in the correct global location of the output mesh </p>

</div>
</div>
<a id="a35fb0731d86f3798588e39c695665155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fb0731d86f3798588e39c695665155">&#9670;&nbsp;</a></span>m_ranks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;int, 9&gt; Cell::m_ranks {{0, -1, -1, -1, -1, -1, -1, -1, -1}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The MPI ranks of all surrounding cells in order: 6 7 8 TL T TR 4 0 5 L C R 1 2 3 BL B BR </p>

</div>
</div>
<a id="ab91310968b7d513398de9db8cc2299cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91310968b7d513398de9db8cc2299cf">&#9670;&nbsp;</a></span>m_unitCell</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_unit_cell.html">UnitCell</a>&gt; Cell::m_unitCell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="class_unit_cell.html">UnitCell</a> that occupies this location in the grid / latice. </p>

</div>
</div>
<a id="a1bde579a85087af8bd96faecfd6820ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bde579a85087af8bd96faecfd6820ff">&#9670;&nbsp;</a></span>min_I_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int64_t&gt; Cell::min_I_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector containing the global node ids of the nodes on the <code>min_I</code> face of this unit cell. These nodes were generated by the "left" (lower i) neighbor. Once this cell uses this information, it can clear out the vector. </p>

</div>
</div>
<a id="adb33c55b234e7c96a1aff9805f3ac77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb33c55b234e7c96a1aff9805f3ac77b">&#9670;&nbsp;</a></span>min_J_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int64_t&gt; Cell::min_J_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector containing the global node ids of the nodes on the <code>min_J</code> face of this unit cell. These nodes were generated by the "below" (lower j neighbor. Once this cell uses this information, it can clear out the vector. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_cell_8h_source.html">Cell.h</a></li>
<li><a class="el" href="_cell_8_c.html">Cell.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
